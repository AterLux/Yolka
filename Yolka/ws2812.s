
/*
 * ws2811.s
 *
 * 
 * Модуль для работы со светодиодными чипами WS2812, а также совместимыми с ними (WS2811, PL9823)
 *
 * Author: Погребняк Дмитрий, г. Самара, 2015
 *
 * Помещённый в этом файле код является свободным. Т.е. допускается его свободное использование для любых целей,
 * включая коммерческие, при условии указания ссылки на автора (Погребняк Дмитрий, http://aterlux.ru/).
 */ 
#define _SFR_ASM_COMPAT 1
#define __SFR_OFFSET 0
#include "ws2812.h"

.global led_data_init

led_data_init:
  cbi LED_DATA_PORT, LED_DATA
  sbi LED_DATA_DDR, LED_DATA
  #ifdef LED_DATA2
    cbi LED_DATA_PORT, LED_DATA2
    sbi LED_DATA_DDR, LED_DATA2
  #endif
ret

// Пауза 2 такта одной командой. Для уменьшения размера кода
#define nop2 rjmp .+0 

// r18-r25, r26-r27 (X), r30-r31 (Z) можно использовать свободно
// r1 - равен нулю и должен быть обнулён, если изменялся. 
// Остальные (r0, r2-r17, r28-r29(Y) ) - нужно сохранять и восстанавливать.
// Входные параметры: [r25:]r24 - первый параметр,  [r23:]r22 - второй, [r21:]r20 - третий, [r19:]r18 - четвёртый, остальные в стеке
// Результат, если есть в [[r23:r22:]r25:]r24 

// Ссылка на переменную с множетилями, которая объявлена в Yolka.c
.extern brightness

.global led_data_out // Ассемблерная функция должна быть объявлена global

// По спецификации WS2812B/WS2811 (в режиме FAST), работаем на 16МГц, допуски ±0.15мкс:
// Весь период передачи одного бита = 1,25мкс = 20 тактов
// - высокий уровень нуля 0.4/0.25 мкс ~= 5 тактов
// - низкий уровень нуля 0.85/1.0 мкс ~= 15 тактов 
// - высокий уровень единицы 0.8/0.6 мкс ~= 12 тактов
// - низкий уровень единицы 0.45/0.65 мкс ~= 8 тактов 

// Первый параметр r25:r24 - указатель на массив с данными
// второй параметр r23:r22 - количество светодиодов.
led_data_out: 
  push r0
  ldi r26, lo8(brightness)
  ldi r27, hi8(brightness);
  ld r18, X+  // r18, r19, r20 - хранят множители для соответствующих компонент цвета. После каждого байта, их значения меняются местами по кругу
  ld r19, X+
  ld r20, X
  // Указатель в X
  movw r26, r24
  // В r25:r24 копируем количество, умноженное на три
  movw r24, r22
  lsl r24
  rol r25
  add r24, r22
  adc r25, r23

  or r22, r23 // Делаем битовое или. Оно будет нулём, только если оба байта нули
  // Теперь в r25:r24 количество байт, которые нужно вывести
  brne .+2 // Если результат операции не ноль, то перескакиваем через 1 команду
    rjmp led_data_out_exit // Иначе выходим.

  in r21, SREG // Сохранение регистра флагов, в т.ч. флага прерываний
  cli // Запрет прерываний
  // в r22 будет текущий байт уже уможенный как надо
  // в r23 счётчик бит и буфер для загрузки очередного байта

  // Предварительная загрузка самого первого байта
  ld r23, X+ // загружаем очередной байт  (2 такта)
  fmul r23, r18 // Умножение со сдвигом влево (2 такта). В r0 - результат умножения
  mov r22, r1 // Загружаем результат умножение (1 такт, операция не меняет флаги)
  brcc .+2 // Переходим через следующую инструкцию, если переполнения не было (2 такта, если переход, 1 такт - если нет)
  ldi r22, 0xFF // Загружма 0xFF, если было переполнение (1 такт)


  first_bit:
	  sbi LED_DATA_PORT, LED_DATA // Устанавливаем высокий уровень на выходе (2 такта)
    // Бит установлен, возьмём этот момент нулевой точкой
    lsl r22 //  сдвигаем влево байт данных (1 такт)
    brcc .+4 // Если была вытолкан нолик, перескакиваем через 2 следующих инструкции (на cbi) (1 такт - нет перехода, 2 - есть)
    nop      // 1 такт
    rjmp .+2 // 2 такта переход
	  cbi LED_DATA_PORT, LED_DATA // Устанавливаем низкий уровень на выходе, если у нас нолик (2 такта)
    // К этому моменту прошло 5 тактов
    mov r0, r18 // Карусель из множителей
    mov r18, r19
    mov r19, r20
    mov r20, r0
    nop
	  cbi LED_DATA_PORT, LED_DATA // Устанавливаем низкий уровень на выходе, что бы там ни было (2 такта)
    // К этому моменту прошло 12 тактов
    nop
    nop2
    nop2

	  ldi r23, 6 // загружаем счётчик бит (1 такт)

    // Биты с 6го по 1й переберём в цикле
	  bit_loop:
	    sbi LED_DATA_PORT, LED_DATA // Устанавливаем высокий уровень на выходе (2 такта)
      // Бит установлен (20 тактов с прошлого бита), возьмём этот момент новой нулевой точкой
      lsl r22 //  сдвигаем влево байт данных (1 такт)
      brcc .+4 // Если была вытолкан нолик, перескакиваем через 2 следующих инструкции (на cbi) (1 такт - нет перехода, 2 - есть)
      nop      // 1 такт
      rjmp .+2 // 2 такта переход
	    cbi LED_DATA_PORT, LED_DATA // Устанавливаем низкий уровень на выходе, если у нас нолик (2 такта)
      // К этому моменту прошло 5 тактов
      nop2 
	    dec r23 // уменьшаем r23 (1 такт)
	    breq bit_loop_out // Выход из цикла, если перебрали все биты в байте (2 такта, если переход, иначе 1)
      nop
	    cbi LED_DATA_PORT, LED_DATA // Устанавливаем низкий уровень на выходе, что бы там ни было (2 такта)
      // К этому моменту прошло 12 тактов
      nop2
      nop2
    rjmp bit_loop // Повторяем цикл для следующих бит (2 такта)

    bit_loop_out:
    // Оказываемся здесь, когда прошло 10 тактов с "момента ноль"
	  cbi LED_DATA_PORT, LED_DATA // Устанавливаем низкий уровень на выходе, что бы там ни было (2 такта)
    // К этому моменту прошло 12 тактов
    sbiw r24, 1 // Уменьшаем на 1  (2 такта)
    breq very_last_bit_out // Если байт не осталось, перескакиваем на вывод самого последнего бита (2 такта, если переход, 1 - если нет)
    // К этому моменту прошло 15 тактов
    ld r23, X+ // загружаем очередной байт  (2 такта)
    nop

    // Начинаем выгрузку бита 0 - последнего бита 

	  sbi LED_DATA_PORT, LED_DATA // Устанавливаем высокий уровень на выходе (2 такта)
    // Бит установлен (20 тактов с прошлого бита), возьмём этот момент новой нулевой точкой
    lsl r22 //  сдвигаем влево байт данных (1 такт)
    brcc .+4 // Если была вытолкан нолик, перескакиваем через 2 следующих инструкции (на cbi) (1 такт - нет перехода, 2 - есть)
    nop      // 1 такт
    rjmp .+2 // 2 такта переход
	  cbi LED_DATA_PORT, LED_DATA // Устанавливаем низкий уровень на выходе, если у нас нолик (2 такта)
    // К этому моменту прошло 5 тактов
    fmul r23, r18 // Умножение со сдвигом влево (2 такта). В r0 - результат умножения
    mov r22, r1 // Загружаем результат умножение (1 такт, операция не меняет флаги)
    nop2
	  cbi LED_DATA_PORT, LED_DATA // Устанавливаем низкий уровень на выходе, что бы там ни было (2 такта, также не меняет флаги) 
    // К этому моменту прошло 11 тактов
    brcc .+2 // Переходим через следующую инструкцию, если переполнения не было (2 такта, если переход, 1 так - если нет)
    ldi r22, 0xFF // Загружма 0xFF, если было переполнение (1 такт)
    // На этот момент прошло 14 тактов и в r22 у нас годный для вывода очередной байтик
    nop2
  rjmp first_bit

very_last_bit_out: // Вывод самого последнего бита. Новый байт не загружается
  // К этому моменту прошло 16 тактов
  nop2
	sbi LED_DATA_PORT, LED_DATA // Устанавливаем высокий уровень на выходе (2 такта)
  // Бит установлен (20 тактов с прошлого бита), возьмём этот момент новой нулевой точкой
  lsl r22 //  сдвигаем влево байт данных (1 такт)
  brcc .+4 // Если была вытолкан нолик, перескакиваем через 2 следующих инструкции (на cbi) (1 такт - нет перехода, 2 - есть)
  nop      // 1 такт
  rjmp .+2 // 2 такта переход
	cbi LED_DATA_PORT, LED_DATA // Устанавливаем низкий уровень на выходе, если у нас нолик (2 такта)
  // К этому моменту прошло 5 тактов
  nop2
  nop2
  nop
	cbi LED_DATA_PORT, LED_DATA // Устанавливаем низкий уровень на выходе, что бы там ни было (2 такта)
  // К этому моменту прошло 12 тактов
  // Далее просто выходим 


  out SREG, r21 // Восстановление флага прерываний
led_data_out_exit:
  pop r0
  clr r1
ret








